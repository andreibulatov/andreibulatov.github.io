# Записки

Пишу на c#, и для решения большинства задачек использую такие штуки:

- [postgres](https://www.postgresql.org)
- [rabbitmq](https://www.rabbitmq.com)
- [dotliquid](https://github.com/dotliquid/dotliquid)
- [ironpython](https://ironpython.net)
- [polly](https://github.com/App-vNext/Polly)
- [docker](https://www.docker.com/)
- [socket.io](https://socket.io/)
- [hangfire](https://www.hangfire.io/)


### Немного подробнее [postgres](https://www.postgresql.org)
Весьма выгодно выглядит для старта проекта, есть всё необходимое, чтоб проект прожил первые полгода и что-то стало понятнее.

Из того, что радует 
- `jsonb`, `xml` довольно часто стал сохранять исходные сообщения, чтоб при необходимости достать дополнительную информацию
- `массивы` - являются спорной частью для бд и любителей НФ, у меня в массивах частенько живут дополнительные данные, которые помогают разобраться, в какой момент что-то пошло не по плану
- `enum` - удобная защита от ввода кривых значений

Из того, что не радует
- столкнулся с не очень очевидным ограничением по количеству записей в синтаксисе `with`, переписал на `pl/pgsql` и проблема прошла
- `pl/pgsql` не очень получилось подружить с [dapper](https://dapper-tutorial.net), проблема была с подстановкой переменных, за 10 минут решение не нашлось, поэтому одну функцию разнес на 2, выполнил в одной транзакции


Из того, о чем стоит помнить
- не любит затяжные транзакции
- pgbouncer (и его ограничения, в зависимости от режима)
- haproxy

### Немного подробнее [rabbitmq](https://www.rabbitmq.com)
Очереди, подходят для взаимодействия между сервисам/компонентами, реализации асинхронной схемы запрос/ответ, и событийной модели, это не очень интересно.

Чуть интереснее - выстраивал на нем pipeline, выглядит неплохо, до момента, когда его нужно менять. 

Важные моменты про pipeline
- для каждого элемента пайплайна
  - создать очередь входящих сообщений
  - эксчейндж исходящих сообщений
  - очередь ошибок
  - формирование имен - абстракция, желательно в базовом классе
  - `enum`, который определяет элемент пайплайна
- сделать биндинги автоматические через `enum` - так проще читать и разбираться что и как идет
- эксчейндж на исходящие лучше делать `direct` и маршрутизировать через `routing key`


### Немного подробнее [dotliquid](https://github.com/dotliquid/dotliquid)
Не открою ничего нового, если скажу, что в шаблонизаторе формирую тексты, подставляя всякие переменные, чаще всего это сообщения клиенту, или, какой-то очень одинаковый формат сообщений для другой системы, в котором меняются только дата отправки, текст, и id сообщения, чтоб не держать иерархию классов для сериализации xml - можно воспользоваться шаблонизатором, смотреться будет понятнее, править приятнее.

Из недавнего использования через `dotliquid` генерировал договор в `html`, а через [i7n-pdfhtml](https://github.com/itext/i7n-pdfhtml) конвертировал в `pdf`, править `html` куда приятнее

### Немного подробнее [ironpython](https://ironpython.net)
С ним история крутится вокруг того, что питон весьма популярен, и его легко продать, если что-то лень делать самостоятельно, главное, не сильно распространяться на тему того, что это не совсем питон :wink:

Основные идея - динамические сценарии, с контекстом.

Прелесть в том, что всякие меняющиеся правила, можно передать на аналитика, захотел поменять логику принятия решений - меняй сам, захотел изменить переменные перед подстановкой в текст - всё в твоих руках, вопрос только в предоставлении контекста.

Был опыт с расширением handlebars, но, это пришлось сделать скорее из-за ограничений внутри команды и работы с ms dynamics crm 


### Чуть подробнее о [polly](https://github.com/App-vNext/Polly)
С микросервисами есть одна большая беда - вызовы большинства методов нужно считать обращениями к агрессивной среде, и без тонкой настройки ретраев обходиться довольно сложно. Всё что хочется от повторов, скорее всего, уже реализовано в этой библиотеке


### Совсем немного о [docker](https://www.docker.com/)
Думаю, что тотально нового здесь ничего не расскажу. Штука не сложная в использовании, можно быстро развернуть какое-нибудь готовое [решение](https://hub.docker.com/) и потыкать, не вдаваясь в тонкую настройку. Можно запаковать свое приложение и развернуть на сервере не занимаясь настройкой окружения и страданиями от разных версий питона/джавы/подставить своё.

Любит память, поэтому важно не забывать о волшебной команде `docker system prune`


### Подробнее о [socket.io](https://socket.io/)

В свое время, когда птицы ещё не летали, и я писал на полном фреймворке, ещё и под `wpf`, была мотивация сделать передачу сообщений от сервера клиенту, ещё хотелось использовать эту механику для соседней команды, они писали на `nodejs`, не стал брать `signalR`, и нашел прекрасную альтернативу. 20 строк на `nodejs` и я получил сервисок, который работает, и, про него уже никто не помнит, хоть и пользуются им весьма активно.

Забавная особенность - касперский считает этот сервис вражеским из-за количества открытых соединений, периодически обрубает все и в логах можно увидеть массовый реконнект, решил просто - добавил процесс в исключения.

В те давние времена использовал [библиотеку](https://github.com/Quobject/SocketIoClientDotNet), устраивала полностью, она устарела, появилась [новая](https://github.com/IBM/socket-io), про неё не могу ничего сказать, не пользовался ¯\\_(ツ)_/¯


### [hangfire](https://www.hangfire.io/)

Использую для выполнение заданий по расписанию, удобен, прост, сделает всё сам, чем и прекрасен.

Важно 
1. Переименование классов может сломать исполнение запланированных задачек
2. Придумав новый job и поставив его исполняться в 12 часов дня, при выкатке приложения в 6 вечера - нужно быть готовым к тому, что job выполнится первый раз в 6 вечера, возможно, это поведение уже изменили